(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global['await-for'] = {})));
}(this, (function (exports) { 'use strict';

  /**
   * Resolves/rejects the promise in one single line
   * @param { Promise } Promise
   * @returns { Promise } Promise that resolves with [ error, data ]
   */
  const here = promise =>
    promise.then(data => [null, data]).catch(err => [err, undefined]);

  /**
   * Seperates out provided job from main thread as Promise and resolves in necessary array pattern.
   * @param {Function} jobToPromisify Heavy thread blocking job to seperate out.
   * @param {Function} catchDefinition A confirmation method to match expectedness of result generated by job.
   * @returns { Promise } here-fied Promise that resolves with [ error, jobResult ]
   */
  const job = (jobToPromisify, catchDefinition, ...additionalJobArgs) =>
    here(
      new Promise((resolve, reject) => {
        const result = jobToPromisify(...additionalJobArgs);
        catchDefinition && !catchDefinition(result)
          ? reject(result)
          : resolve(result);
      })
    );

  /**
   * @param {Promise} promise Actual promise to transform
   * @param  {Functions} transformations List of transform function to pipe promise result through.
   * @returns { Promise } here-fied Promise that resolves with [ error, resultAfterTransformations ]
   */
  const chain = (promise, ...transformations) => {
    const promiseChain = transformations.reduce((chain, tarnsformer) => {
      return chain.then(data => promise.resolve(tarnsformer(data)));
    }, promise);
    return here(promiseChain.catch(err => promise.reject(err)));
  };

  exports.here = here;
  exports.job = job;
  exports.chain = chain;
  exports.default = here;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
